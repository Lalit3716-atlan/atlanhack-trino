---
description:
globs:
alwaysApply: false
---
# Observability Guidelines for Atlan Apps

## Overview

This document outlines the observability patterns and best practices for applications built with the Atlan Application SDK. It covers logging, metrics, and tracing, ensuring consistent, secure, and effective observability across all components. Adhering to these guidelines facilitates debugging, monitoring, and performance analysis.

## Core Principles

1.  **Security First**:
    *   NEVER log sensitive data (PII, passwords, tokens, connection strings) in plaintext.
    *   Use masking or hashing for sensitive fields required for context.
    *   Audit security-relevant events separately, if necessary.
2.  **Structured Data**:
    *   Utilize structured logging (e.g., JSON format) for easier querying and analysis.
    *   Include relevant context (workflow IDs, activity names, request IDs) in logs, metrics, and traces.
3.  **Correlation**:
    *   Ensure logs, metrics, and traces can be correlated using common identifiers (e.g., `workflow_id`, `workflow_run_id`, trace IDs).
    *   Maintain context propagation throughout workflow executions and activity calls.
4.  **Signal vs Noise**:
    *   Log errors appropriately, avoiding redundant messages. Log once per error instance unless additional context is vital.
    *   Keep logs concise and actionable. Avoid excessive verbosity (DEBUG level) in production unless actively debugging.
    *   Focus metrics on key performance indicators (KPIs) and system health.

## Core Components

Observability in the SDK context primarily revolves around structured logging, with standard practices recommended for metrics and tracing.

### 1. Logging

The SDK provides helpers for standardized logging integrated with Temporal workflows and activities.

- **Logger Configuration**
    - Use `AtlanLoggerAdapter` for all logging
    - Configure loggers using `get_logger(__name__)`
    - Use structured logging with context
    - Include request IDs in logs
    - Use appropriate log levels:
        - DEBUG: Detailed information for debugging
        - INFO: General operational information
        - WARNING: Warning messages for potential issues
        - ERROR: Error messages for recoverable errors
        - CRITICAL: Critical errors that may cause system failure
        - ACTIVITY: Activity-specific logging

- **Log Format**
    ```python
    "<green>{time:YYYY-MM-DD HH:mm:ss}</green> <blue>[{level}]</blue> <cyan>{extra[logger_name]}</cyan> - <level>{message}</level>"
    ```

- **Logging Best Practices**
    - Include relevant error_code for the log message being logged. all the error codes are defined in `application-sdk/common/error_codes.py`
    - If you think you cannot find any error_code for the scenario which is being logged, create a new one by modifying `error_codes.py`
    - Include relevant context in log messages
    - Use structured logging for machine processing
    - Log exceptions with stack traces
    - Include request IDs in distributed systems
    - Use appropriate log levels
    - Avoid logging sensitive information
    - Include workflow and activity context in Temporal workflows

- **Example Usage**
    ```python
    from application_sdk.observability.logger_adaptor import get_logger
    from application_sdk.common.error_codes import ApiError

    logger = get_logger(__name__)

    # Basic logging
    logger.info("Operation completed successfully")

    # Logging with context
    logger.info("Processing request", extra={"request_id": "123", "user": "john"})

    # Error logging
    try:
        # Some operation
        pass
    except Exception as e:
        logger.error(error_code=ApiError.UNKNOWN_ERROR.code, "Operation failed", exc_info=True)
    ```


#### Security Considerations

*   Review logs regularly for accidentally logged sensitive data.
*   Implement masking or filtering if sensitive data might appear in logs. The `logger_adaptors` may offer features or require custom wrappers for this.

# Logging Guidelines

## Rule: use-error-logging

**Description:** Use ERROR level for unrecoverable errors and critical failures
**Severity:** error

**When to use:**
- For application crashes
- For unhandled exceptions
- For critical business logic failures
- For configuration errors that prevent startup

**Examples:**
- correct :  `logging.error("Failed to initialize critical component", exc_info=True)`
- correct :  `logging.error(f"Database connection failed after {retries} retries: {error}")`
- wrong : `logging.info("Database connection failed")` â€” Critical errors should not be INFO

---

## Rule: use-warning-logging

**Description:** Use WARNING level for potentially harmful situations
**Severity:** warning

**When to use:**
- For deprecated feature usage
- For runtime issues that can be recovered from
- For unexpected but handled conditions

**Examples:**
- correct : `logging.warning(f"Unexpected branch '{branch}'. Using fallback.")`
- correct : `logging.warning("API rate limit reached, retrying in 60 seconds")`
- wrong : `logging.error("API rate limit reached")` â€” Not severe enough for ERROR

---

## Rule: use-info-logging

**Description:** Use INFO level for general operational events
**Severity:** info

**When to use:**
- For application startup/shutdown
- For significant state changes
- For important business events

**Examples:**
- correct : `logging.info(f"Starting version update process")`
- correct : `logging.info(f"Successfully processed {count} items")`
- wrong : `logging.debug("Starting version update")` â€” Too important for DEBUG

---

## Rule: use-debug-logging

**Description:** Use DEBUG level for detailed troubleshooting information
**Severity:** info

**When to use:**
- For detailed flow information
- For variable values during development
- For step-by-step execution details

**Examples:**
- correct :  `logging.debug(f"Processing item {item_id} with parameters: {params}")`
- correct : `logging.debug("Entering method with args: %s", args)`
- wrong : `logging.info("Variable x = 5")` â€” Too detailed for INFO

---

## Rule: include-context-in-logs

**Description:** Include relevant context in log messages
**Severity:** warning

**When to use:**
- Always include relevant identifiers
- Include state information for errors
- Include timing for performance-related logs

**Examples:**
- correct : `logging.error(f"Failed to process order {order_id}: {error}", exc_info=True)`
- correct :`logging.info(f"Request completed in {duration}ms [request_id={request_id}]")`
- wrong : `logging.error("Operation failed")` â€” Missing context

---

## Rule: use-exception-info

**Description:** Include exception information for errors
**Severity:** error

**When to use:**
- Always include `exc_info=True` for exceptions
- Include stack traces for errors

**Examples:**
- correct : `logging.error("Failed to process request", exc_info=True)`
- correct : `logging.exception("Unexpected error occurred")`
- wrong : `logging.error(str(e))` â€” Missing stack trace



### 2. Metrics (Standard Practices)

- All the metric related information is defined in `observability.metric_adaptor` and its related configuration could be found in `constants.py`.
- All the configuration specific to metrics would be prefixed by the word `METRIC_` before the configuration name along with `ATLAN_`

# Metric Best Practices

## Naming Conventions
- Use **snake_case** for metric names: `application_startup_failure`.
- Names should be **descriptive and action-oriented**, e.g., `task_queue_latency_seconds`.
- Prefix with domain if needed: `db_query_duration_seconds`.

## Types of Metrics

- **Counter**: Monotonic; use to count events (`http_requests_total`, `error_count`).
- **Gauge**: Arbitrary value that goes up and down (`memory_usage_bytes`, `queue_length`).
- **Histogram**: Distribution over intervals (latency, payload size).
- Use `MetricTypes` defined in application_sdk.observability.metric_adaptor to use it

## Labels (Tags)
- Always use **low-cardinality** labels (`env`, `service`, `status_code`, `method`).
- Avoid high-cardinality labels (`user_id`, `timestamp`, `uuid`).
- Labels should help slice and dice metrics meaningfully.

## Descriptions & Units
- **Always include** a human-readable description and a clear unit.
- Example: `Latency of HTTP requests in seconds`.

## Metric Granularity
- Balance granularity with cost. Avoid excessive detail that isn't actionable.
- Use **sampling** or **aggregation** if data is too high-frequency.

## Metric Example (Python)

```python
from application_sdk.observability.metrics_adaptor import get_metrics, MetricType

metrics = get_metrics()

# Record application startup failure
metrics.record_metric(
    name="application_startup_failure",
    value=1,
    metric_type=MetricType.COUNTER,
    labels={"application": APPLICATION_NAME, "error": str(e)},
    description="Application startup failures",
    unit="count",
)


## Best Practices

*   **Instrument Early**: Integrate logging, metrics, and tracing from the start.
*   **Correlate Everything**: Use common IDs (`workflow_id`, `trace_id`) across all signals.
*   **Focus on SLIs/SLOs**: Define Service Level Indicators and Objectives, and build dashboards around them.
*   **Alerting**: Set up meaningful alerts based on error rates, latency spikes, and resource saturation, but avoid alert fatigue.
*   **Regular Review**: Periodically review logs, metrics dashboards, and traces to understand system behavior and identify potential issues.
*   **Security Audits**: Ensure observability configurations and data do not expose sensitive information.

# ðŸ“¡ Trace Best Practices

## âœ… When to Use Traces
- Use tracing for **observability across services and async boundaries**.
- Ideal for **debugging latency, failures, and dependencies** across systems.

## âœ… Core Trace Concepts
- **Trace**: A full request journey across systems.
- **Span**: A single operation within a trace (e.g., DB call, external API call).
- **Trace ID**: Unique per request.
- **Span ID**: Unique per span; forms parent-child relationships.
- **Attributes**: Key-value data to enrich spans (e.g., `user_id`, `env`).
- **Events**: Time-stamped occurrences during the span (e.g., errors).
- **Status**: Indicates `OK`, `ERROR`, etc.

## âœ… Naming and Structure
- Use **snake_case** and be descriptive: `application_startup`, `db_query`.
- Span names should reflect **what is happening**, not where.

## âœ… Span Kinds
- `INTERNAL`: Default, within your app.
- `SERVER`: Handles incoming request.
- `CLIENT`: Makes an external call.
- `PRODUCER`/`CONSUMER`: Message queue interactions.

## âœ… Best Practice: Minimal Trace Example

```python
import time
from application_sdk.observability.traces import get_traces

traces = get_traces()
start_time = time.time()
trace_id = "abc123"
root_span_id = "root456"

try:
    # application logic...
    pass
except Exception as e:
    traces.record_trace(
        name="application_startup",
        trace_id=trace_id,
        span_id=root_span_id,
        kind="INTERNAL",
        status_code="ERROR",
        attributes={"application": APPLICATION_NAME},
        events=[
            {
                "name": "application_startup_failure",
                "timestamp": time.time(),
                "attributes": {"error": str(e)},
            }
        ],
        duration_ms=(time.time() - start_time) * 1000,
    )
```

